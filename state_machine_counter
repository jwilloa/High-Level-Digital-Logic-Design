--------------------------------------------------------------------------------------
------ Company: 
------ Engineer: 
------ 
------ Create Date: 28.01.2020 16:11:56
------ Design Name: 
------ Module Name: counter - Behavioral
------ Project Name: 
------ Target Devices: 
------ Tool Versions: 
------ Description: 
------ 
------ Dependencies: 
------ 
------ Revision:
------ Revision 0.01 - File Created
------ Additional Comments:
------ 
--------------------------------------------------------------------------------------


LIBRARY IEEE;
USE IEEE.STD_LOGIC_1164.ALL;
USE IEEE.numeric_std.ALL;

ENTITY counter is

GENERIC ( width  : NATURAL := 4;
          modulo : NATURAL := 10);         

    PORT ( clk          : in  STD_LOGIC;
           one_sec_clk  : in  STD_LOGIC;          
           input        : in  STD_LOGIC; 
           set          : in  STD_LOGIC; 
           increase     : in  STD_LOGIC; 
           decrease     : in  STD_LOGIC;  
           c_in         : in  STD_LOGIC;  
           reset_in     : in  STD_LOGIC;       
           c_out        : out STD_LOGIC;
           c_up_out     : out STD_LOGIC;
           c_dwn_out    : out STD_LOGIC;
           reset_out    : out STD_LOGIC; 
           state_driver : out UNSIGNED (3 downto 0)
         );
END counter;

architecture Behavioral of counter is

SIGNAL count : UNSIGNED (3 downto 0);
TYPE   state is (state_0, state_1);  -- Different states
SIGNAL curr_state, nx_state : state;-- Signals for current state and next state

begin

-- begin state machine 
    state_register : process (set, clk)
    begin 
        if set = '1' then -- If btnC is pressed stop counting
             curr_state <= state_0; -- Jump to state_0 and initate code there
        elsif RISING_EDGE (clk) then -- Else jump to next state
             curr_state <= nx_state;
        end if;   
    end process;

    state_transition : process (curr_state, input, count, one_sec_clk)
    begin
       case curr_state is        
           when  state_0 =>
              if (input = '1') then
               nx_state <= state_1; -- Go to state 1 and check there as well
               count    <= count + "0000"; -- Stop counting whilst button is held     
     
              else 
                 nx_state <= state_0; -- Set state as state_0
              if RISING_EDGE (one_sec_clk) then --if rising_edge(clk) then 
                if (increase = '1') and  count = (modulo - 1) then 
                    count <= "0000";--(others => '0'); -- Count equals 0 if max number is hit and BtnU is pressed
                elsif (decrease = '1') and  count = "0000" then 
                        count <= modulo - "0001";--(others => '0'); -- Count equals 0 if max number is hit and BtnU is pressed                  
                elsif increase = '1' and count < modulo then -- If count is less than 
                    count <= count + "0001" ;    
                elsif decrease = '1' and count > "0000" then -- If count is less than 
                    count <= count - "0001" ;  
                elsif (reset_in = '1') then -- If count is less than 
                        count <= "0000";               
                end if;     
              end if;
              end if; 
                              
           when state_1 => 
            if (input = '1') then 
                nx_state <= state_0;
                count    <= count + "0000";                   
                   
            else
                nx_state <= state_1; 
            if RISING_EDGE (one_sec_clk) then 
                if (c_in = '1') and (count = "0000") then              -- countdown timer 
                    count <=  (modulo - "0001");--to_unsigned((modulo - 1), width);
                elsif c_in = '1' then 
                    count <= count - "0001" ;                 
                elsif increase = '1' and count < modulo then -- If count is less than 
                    count <= count - "0001" ;       
                elsif decrease = '1' and count > modulo then -- If count is less than 
                    count <= count + "0001" ;             
                end if; 
            end if; 
            end if ; 
       end case; 
    end process;  
   
    state_driver <= count;    
    c_out     <= '1' when (c_in ='1')      and (count = "0000") else '0';   
    c_up_out  <= '1' when (increase = '1') and (count = "1001") else '0';
    c_dwn_out <= '1' when (decrease = '1') and (count = "0000") else '0';
    reset_out <= '1' when (decrease = '1') or  (increase = '1') else '0';
end Behavioral;
